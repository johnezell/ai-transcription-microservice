#!/bin/bash

# Exit immediately if a command exits with a non-zero status.
set -e

# --- Configuration ---
AWS_PROFILE="tfs-shared-services"
AWS_REGION="us-east-1"
CDK_STACK_NAME="CdkInfraStack"
# Output .env file will be created in the app/laravel directory for Docker Compose to use
LARAVEL_APP_DIR="app/laravel"
ENV_FILE_NAME=".env.docker-aws" # Name of the env file to be generated
OUTPUT_ENV_FILE="${LARAVEL_APP_DIR}/${ENV_FILE_NAME}"

# Determine workspace root assuming the script is in <WORKSPACE_ROOT>/scripts/
WORKSPACE_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/.."

cd "${WORKSPACE_ROOT}" # Run AWS CLI commands from workspace root

# --- Check for jq ---
echo "Checking for jq (JSON processor)..."
if ! command -v jq &> /dev/null
then
    echo "Error: jq is not installed or not in PATH. Please install jq to parse AWS CLI JSON output." >&2
    echo "On macOS: brew install jq" >&2
    echo "On Debian/Ubuntu: sudo apt-get install jq" >&2
    exit 1
fi
echo "jq found."

# --- Banner ---
echo "--------------------------------------------------"
echo "Setting up Local Laravel Environment File for AWS Integration"
echo "Target .env file: ${OUTPUT_ENV_FILE}"
echo "Using AWS Profile: ${AWS_PROFILE}"
echo "Using AWS Region: ${AWS_REGION}"
echo "Querying CDK Stack: ${CDK_STACK_NAME}"
echo "--------------------------------------------------"

# --- Fetch AWS Resource Details ---
echo "Fetching AWS resource details from CloudFormation stack '${CDK_STACK_NAME}'..."

DB_ENDPOINT=$(aws cloudformation describe-stacks --stack-name "${CDK_STACK_NAME}" --query "Stacks[0].Outputs[?OutputKey=='DbClusterEndpointOutput'].OutputValue" --output text --profile "${AWS_PROFILE}" --region "${AWS_REGION}")
DB_SECRET_ARN=$(aws cloudformation describe-stacks --stack-name "${CDK_STACK_NAME}" --query "Stacks[0].Outputs[?OutputKey=='DbClusterSecretArnOutput'].OutputValue" --output text --profile "${AWS_PROFILE}" --region "${AWS_REGION}")
S3_BUCKET=$(aws cloudformation describe-stacks --stack-name "${CDK_STACK_NAME}" --query "Stacks[0].Outputs[?OutputKey=='AppDataBucketNameOutput'].OutputValue" --output text --profile "${AWS_PROFILE}" --region "${AWS_REGION}")

if [ -z "${DB_ENDPOINT}" ] || [ "${DB_ENDPOINT}" == "None" ]; then echo "Error: Could not fetch DB_ENDPOINT." >&2; exit 1; fi
if [ -z "${DB_SECRET_ARN}" ] || [ "${DB_SECRET_ARN}" == "None" ]; then echo "Error: Could not fetch DB_SECRET_ARN." >&2; exit 1; fi
if [ -z "${S3_BUCKET}" ] || [ "${S3_BUCKET}" == "None" ]; then echo "Error: Could not fetch S3_BUCKET." >&2; exit 1; fi

echo "DB Endpoint: ${DB_ENDPOINT}"
echo "DB Secret ARN: ${DB_SECRET_ARN}"
echo "S3 Bucket: ${S3_BUCKET}"

echo "Fetching DB credentials from Secrets Manager..."
SECRET_JSON=$(aws secretsmanager get-secret-value --secret-id "${DB_SECRET_ARN}" --query SecretString --output text --profile "${AWS_PROFILE}" --region "${AWS_REGION}")

if [ -z "${SECRET_JSON}" ]; then echo "Error: Could not fetch DB credentials from Secrets Manager." >&2; exit 1; fi

DB_USERNAME=$(echo "${SECRET_JSON}" | jq -r .username)
DB_PASSWORD=$(echo "${SECRET_JSON}" | jq -r .password)
DB_NAME=$(echo "${SECRET_JSON}" | jq -r .dbname)

if [ -z "${DB_USERNAME}" ] || [ "${DB_USERNAME}" == "null" ]; then echo "Error: Could not parse DB_USERNAME from secret." >&2; exit 1; fi
if [ -z "${DB_PASSWORD}" ] || [ "${DB_PASSWORD}" == "null" ]; then echo "Error: Could not parse DB_PASSWORD from secret." >&2; exit 1; fi
if [ -z "${DB_NAME}" ] || [ "${DB_NAME}" == "null" ]; then echo "Error: Could not parse DB_NAME from secret (expected value like 'appdb')." >&2; exit 1; fi

echo "DB Username: ${DB_USERNAME}"
echo "DB Name: ${DB_NAME}"

# --- Create/Update .env file ---
echo "Creating/Updating ${OUTPUT_ENV_FILE}..."

# Ensure the target directory exists
mkdir -p "${WORKSPACE_ROOT}/${LARAVEL_APP_DIR}"

# Create or clear the .env file
>"${WORKSPACE_ROOT}/${OUTPUT_ENV_FILE}"

cat <<EOL > "${WORKSPACE_ROOT}/${OUTPUT_ENV_FILE}"
# This file is auto-generated by scripts/setup_local_env.sh
# Ensure this file (or a pattern like app/laravel/.env.*) is in your .gitignore if it contains secrets.

APP_NAME="Laravel Transcription Service (Local AWS)"
APP_ENV=local
APP_KEY= # IMPORTANT: Copy from main .env or run 'php artisan key:generate' in container
APP_DEBUG=true
APP_URL=http://localhost:8080

LOG_CHANNEL=stderr
LOG_LEVEL=debug

QUEUE_CONNECTION=sync

DB_CONNECTION=mysql
DB_HOST=${DB_ENDPOINT}
DB_PORT=3306
DB_DATABASE=${DB_NAME}
DB_USERNAME=${DB_USERNAME}
DB_PASSWORD='${DB_PASSWORD}'

FILESYSTEM_DISK=s3

AWS_PROFILE=${AWS_PROFILE}
AWS_SHARED_CREDENTIALS_FILE=/mnt/aws_creds_mounted/credentials
AWS_CONFIG_FILE=/mnt/aws_creds_mounted/config
AWS_BUCKET=${S3_BUCKET}
AWS_DEFAULT_REGION=${AWS_REGION}
AWS_USE_PATH_STYLE_ENDPOINT=false

# Mocked service URLs for local development
AUDIO_SERVICE_URL=http://mock-audio.internal.test:5000
TRANSCRIPTION_SERVICE_URL=http://mock-transcription.internal.test:5000
TERMINOLOGY_SERVICE_URL=http://mock-terminology.internal.test:5000
MUSIC_TERM_SERVICE_URL=http://mock-terminology.internal.test:5000

# Standard Laravel Mix/Vite Pusher placeholders (copy from your main .env if needed)
MIX_PUSHER_APP_KEY="\${PUSHER_APP_KEY}"
MIX_PUSHER_APP_CLUSTER="\${PUSHER_APP_CLUSTER}"
EOL

# Attempt to copy APP_KEY from an existing app/laravel/.env
EXISTING_ENV_FILE="${WORKSPACE_ROOT}/${LARAVEL_APP_DIR}/.env"
if [ -f "${EXISTING_ENV_FILE}" ]; then
    EXISTING_APP_KEY=$(grep '^APP_KEY=' "${EXISTING_ENV_FILE}" | cut -d '=' -f2-)
    if [ -n "${EXISTING_APP_KEY}" ]; then
        # Correctly escape for sed: & needs to be \&, / needs to be \/, etc.
        # For APP_KEY which is base64, forward slashes are the main concern.
        SAFE_APP_KEY=$(echo "${EXISTING_APP_KEY}" | sed 's/[&/]/\\&/g')
        if [[ "$(uname)" == "Darwin" ]]; then # macOS
            sed -i '' "s|^APP_KEY=.*$|APP_KEY=${SAFE_APP_KEY}|" "${WORKSPACE_ROOT}/${OUTPUT_ENV_FILE}"
        else # Linux
            sed -i "s|^APP_KEY=.*$|APP_KEY=${SAFE_APP_KEY}|" "${WORKSPACE_ROOT}/${OUTPUT_ENV_FILE}"
        fi
        echo "Copied APP_KEY from existing ${EXISTING_ENV_FILE}"
    else
        echo "Warning: APP_KEY not found or empty in ${EXISTING_ENV_FILE}. Set it manually in ${WORKSPACE_ROOT}/${OUTPUT_ENV_FILE} or run 'php artisan key:generate' in the container."
    fi
else
    echo "Warning: No existing ${EXISTING_ENV_FILE} found to copy APP_KEY from. Set it manually in ${WORKSPACE_ROOT}/${OUTPUT_ENV_FILE} or run 'php artisan key:generate' in the container."
fi

echo "--------------------------------------------------"
echo "Local environment file '${WORKSPACE_ROOT}/${OUTPUT_ENV_FILE}' created/updated."
echo "Please ensure your docker-compose.override.yml is configured to use this env_file for the 'laravel' service:"
echo "  services:"
echo "    laravel:"
echo "      env_file:"
echo "        - ./${LARAVEL_APP_DIR}/${ENV_FILE_NAME}" # Path relative to docker-compose files at workspace root
echo "Make sure to fill in any other required .env variables (like APP_KEY if not copied and not generated)."
echo "--------------------------------------------------"